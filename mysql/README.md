5.mysql


* MySQL 的存储引擎用的是什么?（InnoDB）为什么选 InnoDB?
    * 几乎所有公司用 MySQL 都用 InnoDB，降低踩坑成本；聚簇索引，MVCC

	语句优化
		explain
			type 命中那些索引
			查找的行数
			有没有额外的排序操作		
	索引怎么建立？
	联合索引怎么样才会命中？
	有用过 MySQL 的什么高级特性吗?
1.innodb 
支持事物，主键，外键，行锁（where主键有效），不支持全文索引，读数据速度比myisam慢，转移很痛苦
2.myisam 
不支持事物，讲究原子性，



* MySQL 的聚簇索引和非聚簇索引有什么区别?
    * 聚簇索引的叶子节点是数据节点（比如定义了主键时的主键索引），非聚簇索引叶子节点是指向数据块的指针
* B+树和二叉树有什么区别和优劣?
    * B+树是多叉树，深度更小，B+树可以对叶子节点进行顺序遍历，B+树能够更好地利用磁盘扇区；二叉树：实现简单
* 针对一个场景设计索引，具体场景忘记了，反正考察的是联合索引与列选择性的知识
* 现有一个新的查询场景, 要怎么解决?
* 假如要查 A in () AND B in (), 怎么建索引?
    * 只给选择性高的一列建索引，这里因为两个都是范围查询所以另一个是走不到索引的（这里答的不好，其实也可以建联合索引然后用 （A,B) in ((1,2),(3,4)) 的方式去查）
* 查 A in () AND B in () 时, MySQL 是怎么利用索引的?
    * 先走一个非聚簇索引，查询出行数据后再用另一列回表做筛选
* 假如查询 A in (), MySQL 是针对 N 个值分别查一次索引, 还是有更好的操作?
    * 不知道，有了解的同学可以留言 (补充, @BillyLu 贴出了文档 equality-range-optimization, 大意是对非唯一索引 MySQL 会使用 index dive 的方式估算这个 range index 涉及的行数, 结合where optimization 中说明的在走 index 时假如涉及行数过多会走 full table scan, 那么假如 estimation 认为这次 IN 不够好, 是会走全表扫描的. 不知道除此之外, 面试官还有没有想考察的点)

* 隔离级别
	* 1.未提交读。脏读。别人修改数据的事务尚未提交,在我的事务中也能读到. 
	* 2.读已提交。重复读。 别人修改数据的事务已经提交,在我的事务中才能读到.
	* 3.可重复读 幻读。 可重复读是怎么实现的。别人修改数据的事务已经提交,在我的事务中也读不到
	* 4.串行化。我的事务尚未提交,别人就别想改数据.


+ 1.查询的索引一定要有。
+ 2.如果出现了复杂的、包含很多子查询的语句，可以拆分开来查询。尽量不要用not !=等模糊的查询。
+ 3.慢查询出现 。explain 分析使用的语句分析优化。查看慢查询的.
	+ 1)type : all < index < range ~index < ref < const <system。
	+ 2）key :查询使用到的索引。
	+ 3）rows :查询西药扫描的数据行数，这个是最直观显示SQL语句效率的好坏；rows越少越好。
	+ 4) Extra: 看是否有额外需要消耗很高性能的操作。如：sorted查询数据还需要排序过程等。
+ 4.语句查询过程。客户端sql语句，首先查询缓存，一般是不打开，可以语句控制先查询缓存。-》语法解析-》预处理-》SQL优化-》查询执行引擎-》返回结果。

实现乐观锁和悲观锁

分库分表怎么实现？ 
